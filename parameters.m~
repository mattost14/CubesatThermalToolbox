%% Main user inputs

numberOfUnits = 6; % options: 1, 3, 6, 12

centralBody = "earth"; % options: "earth", "moon", "mars"

facesMaterial = ["goldCoating", "whiteCoating", "solarCell", "solarCell", "solarCell", "solarCell"]; % options: "solarCell", "blackCoating", "whiteCoating", "goldCoating"
% facesMaterial = ["goldCoating", "whiteCoating", "goldCoating", "goldCoating", "solarCell", "goldCoating"]; % options: "solarCell", "blackCoating", "whiteCoating", "goldCoating"

payloadPwr = 7; %Internal heat generation power (W)

payload2FacesConductivity = [8, 8, 8, 8, 8, 8]; %(W/K) - Thermal conductivity between internal node with each face

%% Input file (must be in the Input folder)
% This file must me generated by STK with following columns:
% 1 - Time (EpSec)
% 2 - x/Magnitude - Solar intensity at X+ and X- faces
% 3 - y/Magnitude - Solar intensity at Y+ and Y- faces
% 4 - z/Magnitude - Solar intensity at Z+ and Z- faces
% 5 - Magnitude - Solar overall intensity (0-1)
% 6 - DirectionAngle x (deg) - Angle between face X+ normal vector with Nadir vector 
% 7 - DirectionAngle y (deg) - Angle between face Y+ normal vector with Nadir vector
% 8 - DirectionAngle z (deg) - Angle between face Z+ normal vector with Nadir vector
% 9 - Alt (km) - Orbit Altitude (km)
% 10 - Angle (deg) - Angle between vector1: Sat->CentralBody and vector2: CentralBody->Sun 
STKReportFileName = "SPORT_ThermalAnalysisEarthOrbit2.csv";

%% Output file (saved in Output folder)

outputFileName = "SPORT_EarthOrbit.mat";
%% Solar Panel

param.solarCellEff = .2; % Solar Cell Efficiency
param.effectiveAreaRatio = .85; % How much of the face area is effective covered by solar cells 

%% Auto generation parameters

satelliteMass = 1*numberOfUnits; % Mass per Unit (default: 1kg/U)

chassis2TotalMassRatio = .25; % How much of the total mass goes for the satellite chassis (default: 25%)

param.Tinf = 4; % Cold Space Temp (K)
sigma = 5.67e-8; % Stefan-Boltzmann constant (W · m -2 · K -4 )
solarFlux = 1380; % Solar flux (W/m2)
unitArea = 0.1*0.1; % Unit area (m2)
plateThickness = .003; % (m)
cornerJointLength = 0.005;
K_Al7075_t7351 = 155; % (W/(m*K)) - Thermal conductivity of Aluminum 7075-t7351 used in cubesat frames
theta_EarthBlockingSunFromMoon = atan2(6371,382500)*180/pi; % (deg) angular distance that Earth starts blocking the Sun from Moon

chassisMass = chassis2TotalMassRatio*satelliteMass;
payloadMass = (1-chassis2TotalMassRatio)*satelliteMass;


switch numberOfUnits
    case 1
        facesMassDistribution = [1/6, 1/6, 1/6, 1/6, 1/6, 1/6]; %[X+,X-,Y+,Y-,Z+, Z-]
        facesArea = facesMassDistribution*(6*unitArea);
        XYUnitsSection = 1;
        XZUnitsSection = 1;
        YZUnitsSection = 1;
    case 3
        facesMassDistribution = [3/14, 3/14, 3/14, 3/14, 1/14, 1/14]; 
        facesArea = facesMassDistribution*(14*unitArea);
        XYUnitsSection = 1;
        XZUnitsSection = 1;
        YZUnitsSection = 3;
    case 6
        facesMassDistribution = [2/22, 2/22, 3/22, 3/22, 6/22, 6/22]; %[6/22, 6/22, 3/22, 3/22, 2/22, 2/22]
        facesArea = facesMassDistribution*(22*unitArea);
        XYUnitsSection = 1;
        XZUnitsSection = 2;
        YZUnitsSection = 3;
    case 12
        facesMassDistribution = [6/32, 6/32, 6/32, 6/32, 4/32, 4/32];
        facesArea = facesMassDistribution*(32*unitArea);
        XYUnitsSection = 2;
        XZUnitsSection = 2;
        YZUnitsSection = 3;
end

% Faces cp
faces_Cp = [getPropertiesFromMaterial(facesMaterial(1)).Cp,...
            getPropertiesFromMaterial(facesMaterial(2)).Cp,...
            getPropertiesFromMaterial(facesMaterial(3)).Cp,...
            getPropertiesFromMaterial(facesMaterial(4)).Cp,...
            getPropertiesFromMaterial(facesMaterial(5)).Cp,...
            getPropertiesFromMaterial(facesMaterial(6)).Cp]; 
emissivity = [getPropertiesFromMaterial(facesMaterial(1)).emiss,...
            getPropertiesFromMaterial(facesMaterial(2)).emiss,...
            getPropertiesFromMaterial(facesMaterial(3)).emiss,...
            getPropertiesFromMaterial(facesMaterial(4)).emiss,...
            getPropertiesFromMaterial(facesMaterial(5)).emiss,...
            getPropertiesFromMaterial(facesMaterial(6)).emiss]; 
param.absorptivity = [getPropertiesFromMaterial(facesMaterial(1)).absorp,...
            getPropertiesFromMaterial(facesMaterial(2)).absorp,...
            getPropertiesFromMaterial(facesMaterial(3)).absorp,...
            getPropertiesFromMaterial(facesMaterial(4)).absorp,...
            getPropertiesFromMaterial(facesMaterial(5)).absorp,...
            getPropertiesFromMaterial(facesMaterial(6)).absorp]; 

% Payload
payloadCp = 903; %J/(kg*K)


%% Interconnections

% Matrix of link between faces
FaceLinks = [%X+, %X-, %Y+, %Y-, %Z+, %Z-
         0, 0, 1, 1, 1, 1;... %X+
         0, 0, 1, 1, 1, 1;... %X-
         1, 1, 0, 0, 1, 1;... %Y+
         1, 1, 0, 0, 1, 1;... %Y-
         1, 1, 1, 1, 0, 0;... %Z+
         1, 1, 1, 1, 0, 0;... %Z+
         ];
         
% Matrix of Faces Thermal Conductivity
k = FaceLinks*K_Al7075_t7351;

% Matrix of Faces Link Area (dependent on number of units)
       %X+, %X-, %Y+, %Y-, %Z+, %Z-
A(1,:) = [  0,   0, XYUnitsSection*.1*plateThickness, XYUnitsSection*.1*plateThickness, XZUnitsSection*.1*plateThickness, XZUnitsSection*.1*plateThickness]; 
A(2,:) = [  0,   0, XYUnitsSection*.1*plateThickness, XYUnitsSection*.1*plateThickness, XZUnitsSection*.1*plateThickness, XZUnitsSection*.1*plateThickness];
A(3,:) = [XYUnitsSection*.1*plateThickness, XYUnitsSection*.1*plateThickness,   0,   0, YZUnitsSection*.1*plateThickness, YZUnitsSection*.1*plateThickness];
A(4,:) = [XYUnitsSection*.1*plateThickness, XYUnitsSection*.1*plateThickness,   0,   0, YZUnitsSection*.1*plateThickness, YZUnitsSection*.1*plateThickness];
A(5,:) = [XZUnitsSection*.1*plateThickness, XZUnitsSection*.1*plateThickness, YZUnitsSection*.1*plateThickness, YZUnitsSection*.1*plateThickness,   0,   0];
A(6,:) = [XZUnitsSection*.1*plateThickness, XZUnitsSection*.1*plateThickness, YZUnitsSection*.1*plateThickness, YZUnitsSection*.1*plateThickness,   0,   0];


% Matrix of Faces link length
       %X+, %X-, %Y+, %Y-, %Z+, %Z-
L = FaceLinks*cornerJointLength;

Conductivity = (k.*A)./L;
Conductivity(7,:) = payload2FacesConductivity;
Conductivity(:,7) = [payload2FacesConductivity'; NaN];
param.Conductivity = Conductivity;

% Radiation coefficient
    %X+, %X-, %Y+, %Y-, %Z+, %Z-, %P
param.krad = [emissivity, 0]*sigma;
param.mass = [facesMassDistribution*chassisMass, payloadMass];
param.cp = [faces_Cp, payloadCp];
param.power = [zeros(1,6), payloadPwr];
param.area = [facesArea, 0];
param.solarFlux = getCentralBodyProperties(centralBody).solarFlux;

%% Reading data from STK Report

orbitalThermalParameters = readtable(STKReportFileName);
orbitalThermalParameters.Time_EpSec_ = seconds(orbitalThermalParameters.Time_EpSec_);

%%% Solar light 
solarLight = orbitalThermalParameters(:,1:5);
solarLight = [seconds(solarLight.Time_EpSec_), ...
              max(-solarLight.x_Magnitude,0),...
              max(solarLight.x_Magnitude,0),...
              max(-solarLight.y_Magnitude,0),...
              max(solarLight.y_Magnitude,0),...
              max(-solarLight.z_Magnitude,0),...
              max(solarLight.z_Magnitude,0),...
              max(solarLight.Magnitude,0)];
if (centralBody=="moon") %if orbiting Moon, it needs to check if Earth is blocking the Sun using the EclipseAngle data
    solarLight(:,2:8) = solarLight(:,2:8).*(orbitalThermalParameters.EclipseAngle_deg_ > theta_EarthBlockingSunFromMoon);
end
solarLight = array2table(solarLight);
solarLight.Properties.VariableNames = {'time','x_plus_magnitude','x_minus_magnitude','y_plus_magnitude','y_minus_magnitude', 'z_plus_magnitude', 'z_minus_magnitude','magnitude'};
solarLight.time = seconds(solarLight.time);
param.solarLight = table2timetable(solarLight);

%%% Planetary IR Geometry Factor
daytime = (orbitalThermalParameters.AlbedoAngle_deg_ - 90 > 0);
if (centralBody=="moon") %if orbiting Moon, it needs to check if Earth is blocking the Sun using the EclipseAngle data
    daytime = daytime.*(orbitalThermalParameters.EclipseAngle_deg_ > theta_EarthBlockingSunFromMoon);
end
param.Pir = daytime*sigma*(getCentralBodyProperties(centralBody).Tir_Day)^4 + (1-daytime)*sigma*(getCentralBodyProperties(centralBody).Tir_Night)^4; % Central body radiation
planetRadius = getCentralBodyProperties(centralBody).radius;
orbitHeight = orbitalThermalParameters.Alt_km_;
phi = acos(planetRadius./(planetRadius+orbitHeight)); % Limb angle
viewFactor(:,1) = seconds(orbitalThermalParameters.Time_EpSec_);
viewFactor(:,2) = arrayfun(@(x,phi) cos(phi)^2*max(0, cos((pi/2)*((x*pi/180)/(pi-phi))))^2.5, orbitalThermalParameters.DirectionAngleX_deg_, phi);
viewFactor(:,3) = arrayfun(@(x,phi) cos(phi)^2*max(0,cos((pi/2)*((x*pi/180)/(pi-phi))))^2.5, 180-orbitalThermalParameters.DirectionAngleX_deg_, phi);
viewFactor(:,4) = arrayfun(@(x,phi) cos(phi)^2*max(0,cos((pi/2)*((x*pi/180)/(pi-phi))))^2.5, orbitalThermalParameters.DirectionAngleY_deg_, phi);
viewFactor(:,5) = arrayfun(@(x,phi) cos(phi)^2*max(0,cos((pi/2)*((x*pi/180)/(pi-phi))))^2.5, 180-orbitalThermalParameters.DirectionAngleY_deg_, phi);
viewFactor(:,6) = arrayfun(@(x,phi) cos(phi)^2*max(0,cos((pi/2)*((x*pi/180)/(pi-phi))))^2.5, orbitalThermalParameters.DirectionAngleZ_deg_, phi);
viewFactor(:,7) = arrayfun(@(x,phi) cos(phi)^2*max(0,cos((pi/2)*((x*pi/180)/(pi-phi))))^2.5, 180-orbitalThermalParameters.DirectionAngleZ_deg_, phi);
viewFactor = array2table(viewFactor);
viewFactor.Properties.VariableNames = {'time','x_plus','x_minus','y_plus','y_minus', 'z_plus', 'z_minus'};
viewFactor.time = seconds(viewFactor.time);
param.viewFactor = table2timetable(viewFactor);

%%% Albedo Angle (Vector1: Sat->EarthCenter) (Vector2: Earth->Sun)
albedoAngle(:,1) = seconds(orbitalThermalParameters.Time_EpSec_);
albedoAngle(:,2) = orbitalThermalParameters.AlbedoAngle_deg_;
if (centralBody=="moon") %if orbiting Moon, it needs to check if Earth is blocking the Sun using the EclipseAngle data
    albedoAngle(:,2) = albedoAngle(:,2).*(orbitalThermalParameters.EclipseAngle_deg_ > theta_EarthBlockingSunFromMoon);
end
albedoAngle = array2table(albedoAngle);
albedoAngle.Properties.VariableNames = {'time','AlbedoAngle_deg_'};
albedoAngle.time = seconds(albedoAngle.time);
param.albedoAngle = table2timetable(albedoAngle);
param.albedoFactor = getCentralBodyProperties(centralBody).albedoFactor;

param.numberOfUnits = numberOfUnits;
param.facesMaterial = facesMaterial;

clearvars -except param outputFileName